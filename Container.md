<img src="https://github.com/dhcho/wiki/blob/main/images/Cloud/%231.png"/>

# 도커와 쿠버네티스 비교 예시
- 컨테이너 하나 띄워서 사용해야지 => 도커

- 0월 0시에 100개의 컨테이너를 자동으로 생성해야지 => 쿠버네티스

- 간단 설명

  - 도커는 '기술적인 개념이자 도구'이고
  - 쿠버네티스는 '도커를 관리하는 툴'이라고 생각하면 된다.
  - 이미지를 컨테이너에 띄우고 실행하는 기술이 도커고
  - 이런 도커를 기반으로 컨테이너를 관리하는 서비스가 쿠버네티스라고 생각하면 된다.
  - 즉, 도커는 '한 개의 컨테이너'를 관리하는 데 최적, 쿠버네티스는 '여러 개의 컨테이너'를 서비스 단위로 관리하는 데 최적화되어있다.


# 도커란?

<img src="https://github.com/dhcho/wiki/blob/main/images/Cloud/%232.png"/>

- 도커는 '컨테이너 기반의 오픈소스 가상화 플랫폼'이다.

- 도커로 컨테이너를 띄운다.

- 컨테이너란?
  - 애플리케이션 & 애플리케이션을 구동하는 환경을 격리한 공간이다.
  - 컨테이너에 프로그램을 띄워서 돌린다고 생각하면 된다.
  - 보통 마이크로서비스로 사용된다.
  - 거대한 어플리케이션을 기능별로 나누어 변경/조합이 가능하게 한 것
  - 컨테이너를 사용하면 하나의 큰 어플을 서비스 단위로 잘라 빠르게 배포 가능.
  - 그리고 각각 분리해서 쓰니 변경사항이 분리된 다른 기능들에 영향 미치지 않음.


- 기존의 가상머신(VM)과 컨테이너의 차이점

<img src="https://github.com/dhcho/wiki/blob/main/images/Cloud/%233.png"/>

- 기존의 가상머신(VM) 서버
    - Server → Hypervisor → 각각의 Guest OS가 설치된 VM 구동
    - 가상 머신의 모든 자원을 사용한다.
 
- 컨테이너 서버
    - Server → Host OS → Docker Engine → Container 올리기
    - CPU, RAM, Disk, Network와 같은 운영체제의 자원을 필요한 만큼 격리하여 컨테이너에 할당
      - 효율적! 배포가 빠름! but 컨테이너 하나가 자원을 많이 사용하면 장애 발생.


- 도커가 가진 컨테이너는 독립적이고, 동적이다.
    - 만약 당신의 java앱이 인기가 많아지면 java 컨테이너의 수를 늘리고, 다시 트래픽이 줄면 해당 컨테이너 수를 줄이면 된다.
    - 즉, docker 덕분에 매번 새로운 서비스를 만들 때마다 새로운 서비스를 사고, 설정할 필요가 없는 것입니다. 당신이 원할 때마다 docker를 통해 새로운 환경을 생성할 수 있습니다.
    - 하나의 같은 서버에서 각기 다른 환경의 컨테이너를 설정할 수 있고, 게다가 이 컨테이너들은 각각 분리, 독립되어 있는 것이기 때문에 더욱 효율적인 것입니다.


# 쿠버네티스란?
<img src="https://github.com/dhcho/wiki/blob/main/images/Cloud/%233.png"/>

- 쿠버네티스는 '컨테이너 오케스트레이션 툴' 이다.

- 오케스트레이션이란?
    - 컨테이너 역시 그 수가 많아지게 되면 관리와 운영에 있어서 어려움이 따른다.
    - 컨테이너 오케스트레이션은 이러한 다수의 컨테이너 실행을 관리 및 조율하는 시스템이다.
    - 오케스트레이션 엔진을 통해 컨테이너의 생성과 소멸, 시작 및 중단 시점 제어, 스케줄링, 로드 밸런싱, 클러스터링 등 컨테이너로 어플리케이션을 구성하는 모든 과정을 관리할 수 있음
    - 다른 컨테이너 오케스트레이션 툴로는 '도커 스웜', 'ECS', 'Nomad'등이 있다.


- 쿠버네티스 특징
  - 자동화된 복구(self-healing)
    - 컨테이너들을 모니터링하며 컨테이너 중 하나라도 죽으면 쿠버네티스는 그것을 빠르게 재시작 시킵니다.


  - 로드 밸런싱(Load balancing)
    - 만약 1만명의 유저가 접속할 경우, 그러나 당신의 웹/앱은 준비가 되지 않았을 경우 쿠버네티스는 해당 웹사이트의 니즈를 수용할 수 있도록 자동으로 새로운 컨테이너들을 만들 수 있습니다.
    - 니즈가 줄어들면 컨테이너를 지정해둔 최소 숫자로 자동으로 조절됩니다. 이전에는 수동으로 했던 작업을 쿠버네티스가 자동으로 도와주는 것입니다.


  - 무중단(Fault tolerance-FT) 서비스
    - 기업에서는 서버 업데이트를 위해서 사용자들이 잠든 새벽 시간을 활용하거나 긴급 점검의 형태로 서비스를 일시 중단해왔습니다.
    - 하지만, 쿠버네티스는 점진적 업데이트를 제공하기 때문에 서비스를 중단하지 않고도 애플리케이션을 업데이트할 수 있습니다.
  
  
  - 호환성(Vendor Lock In 해결)
    - 고객이 A사의 클라우드를 사용하다가 I사의 클라우드로 환경을 이전하고 싶을 때, 서로 다른 업체(Vendor)의 클라우드 제품 간에 호환 문제가 발생하여 이전하기 어려운 상황을 Vendor Lock In이라고 합니다.
    - 쿠버네티스는 도커 컨테이너를 기반으로 하는 오픈소스이기 때문에 사용자들이 특정 업체에 종속되지 않고 클라우드의 환경들을 이전할 수 있습니다.
    - 현재 쿠버네티스는 구글, 마이크로소프트, 아마존 클라우드에서 사용할 수 있으며 다른 마이크로서비스 관리 시스템들도 한 클라우드 플랫폼에 한정되기도 하지만 쿠버네티스로 할 수 있는 가이드를 제시해줘서 한 번 쿠버네티스를 익히면 provider 회사에 상관없이 공통된 마이크로서비스 아키텍쳐 개발이 가능합니다.


# 요약
- 도커와 쿠버네티스는 상황마다 다르게 사용된다.
- 한 개의 인스턴스만 이용하면 쿠버네티스는 필요 없다.
- 쿠버네티스는 많은 컨테이너 관리에 유용한 것이다.
